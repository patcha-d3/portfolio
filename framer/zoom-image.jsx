// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project a388a4e8c1271596 "Pat's", do not edit manually */
"use client";

/**
 * @typedef Locale
 * string
 */

/**
 * @typedef {{
 * children?: React.ReactNode
 * locale?: Locale
 * style?: React.CSSProperties
 * className?: string
 * id?: string
 * ref?: any
 * width?: any
 * height?: any
 * layoutId?: string
 * image?: {src: string, srcSet?: string, alt?: string} // Image
 * zoomScale?: number // Zoom Scale
 * transition?: any // Transition
 * background?: string // Background
 * borderRadius?: number // Border Radius
}} Props

 */
import { routes } from "./chunks/chunk-LKSUI2VU.js";

// virtual:zoom-image
import { Fragment } from "react";
import { ContextProviders } from "unframer";

// /:https://framerusercontent.com/modules/tqTeeXB8qqNbF2yNesUZ/rUGPY4mPRdBttlxpiZSv/ZoomImage.js
import { jsx as _jsx } from "react/jsx-runtime";
import { motion } from "unframer";
import { useState, startTransition } from "react";
import {
	addPropertyControls,
	ControlType,
	useIsStaticRenderer,
} from "unframer";
function ZoomImage(props) {
	const {
		image = {
			src: "https://framerusercontent.com/images/70D908ZnP0cnDre3T7DlePO12M.jpeg",
			alt: "3D Gradient Waves",
		},
		zoomScale,
		transition,
		backgroundColor,
		borderRadius,
	} = props;
	const [isHovered, setIsHovered] = useState(false);
	const isStatic = useIsStaticRenderer();
	const zoomInStyle = {
		scale: zoomScale,
	};
	const zoomOutStyle = {
		scale: 1,
	};
	const updateTransformOrigin = (e) => {
		if (isStatic) return;
		const rect = e.currentTarget.getBoundingClientRect();
		const x = e.clientX - rect.left;
		const y = e.clientY - rect.top;
		const childElement = e.currentTarget.firstChild;
		if (childElement) {
			childElement.style.transformOrigin = `${x}px ${y}px`;
		}
	};
	const handleMouseEnter = () => {
		if (!isStatic) {
			startTransition(() => setIsHovered(true));
		}
	};
	const handleMouseLeave = () => {
		if (!isStatic) {
			startTransition(() => setIsHovered(false));
		}
	};
	return (
		<motion.div
			style={{
				...props.style,
				overflow: "hidden",
				position: "relative",
				backgroundColor,
				borderRadius,
				width: "100%",
				height: "100%",
				border: "1px solid #EEEEEE",
			}}
			onMouseMove={isStatic ? void 0 : updateTransformOrigin}
			onMouseEnter={handleMouseEnter}
			onMouseLeave={handleMouseLeave}
		>
			<motion.div
				animate={isHovered ? zoomInStyle : zoomOutStyle}
				transition={transition}
				style={{
					width: "100%",
					height: "100%",
					display: "flex",
					alignItems: "center",
					justifyContent: "center",
				}}
			>
				<img
					{...image}
					style={{
						width: "100%",
						height: "100%",
						objectFit: "cover",
						transition: void 0,
					}}
				/>
			</motion.div>
		</motion.div>
	);
}
addPropertyControls(ZoomImage, {
	image: {
		type: ControlType.ResponsiveImage,
		title: "Image",
	},
	zoomScale: {
		type: ControlType.Number,
		title: "Zoom Scale",
		defaultValue: 2.5,
		min: 1.1,
		max: 5,
		step: 0.1,
	},
	transition: {
		type: ControlType.Transition,
		title: "Transition",
		defaultValue: {
			duration: 0.1,
			ease: "easeInOut",
		},
	},
	backgroundColor: {
		type: ControlType.Color,
		title: "Background",
		defaultValue: "#FFFFFF",
	},
	borderRadius: {
		type: ControlType.Number,
		title: "Border Radius",
		defaultValue: 8,
		min: 0,
		max: 50,
		step: 1,
		unit: "px",
	},
});

// virtual:zoom-image
import { WithFramerBreakpoints } from "unframer";
import { jsx } from "react/jsx-runtime";
var locales = [];
var defaultResponsiveVariants = {};
/** @type {function(Props): any} */
function ComponentWithRoot({ locale, ...rest }) {
	return (
		<ContextProviders
			routes={routes}
			framerSiteId={
				"a388a4e8c1271596c25793932fb9581943efabb7f04a942d74fc0b8c62dc4850"
			}
			locale={locale}
			locales={locales}
		>
			<ZoomImage {...rest} />
		</ContextProviders>
	);
}
/**
 * @type {import("unframer").UnframerBreakpoint}
 * Represents a responsive breakpoint for unframer.
 */

/**
 * @typedef VariantsMap
 * Partial record of UnframerBreakpoint to Props.variant, with a mandatory 'base' key.
 * { [key in UnframerBreakpoint]?: Props['variant'] } & { base: Props['variant'] }
 */

/**
 * Renders ZoomImageFramerComponent for all breakpoints with a variants map. Variant prop is inferred per breakpoint.
 * @function
 * @param {Omit<Props, 'variant'> & {variants?: VariantsMap}} props
 * @returns {any}
 */
ComponentWithRoot.Responsive = ({ locale = "", ...rest }) => {
	return (
		<ContextProviders
			routes={routes}
			framerSiteId={
				"a388a4e8c1271596c25793932fb9581943efabb7f04a942d74fc0b8c62dc4850"
			}
			locale={locale}
			locales={locales}
		>
			<WithFramerBreakpoints
				Component={ZoomImage}
				variants={defaultResponsiveVariants}
				{...rest}
			/>
		</ContextProviders>
	);
};
Object.assign(ComponentWithRoot, ZoomImage);
var zoom_image_default = ComponentWithRoot;
export { zoom_image_default as default };
